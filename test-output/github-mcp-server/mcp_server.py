"""
MCP Server for github SDK

Auto-generated by SDK-to-MCP converter.
"""

import asyncio
import json
import logging
import os
import sys
from typing import Any, Dict, List, Optional, Union
from pathlib import Path

# MCP imports
from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.server.lowlevel.server import NotificationOptions
from mcp.server.stdio import stdio_server
from mcp.types import (
    Resource, Tool, TextContent, ImageContent, EmbeddedResource,
    CallToolRequest, CallToolResult, ListResourcesRequest, ListResourcesResult,
    ReadResourceRequest, ReadResourceResult, GetPromptRequest, GetPromptResult,
    Prompt, PromptMessage, PromptArgument
)
from mcp import types

# SDK imports
import github

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class AuthenticationManager:
    """Manages authentication for the GitHub SDK."""
    
    def __init__(self):
        self.credentials = {}
        self._load_credentials()
    
    def _load_credentials(self):
        """Load GitHub credentials from environment variables or config file."""
        # Load GitHub-specific environment variables
        github_vars = ["GITHUB_TOKEN", "GITHUB_ACCESS_TOKEN"]
        
        for var in github_vars:
            value = os.getenv(var)
            if value:
                self.credentials[var.lower()] = value
        
        # Load from config file if it exists
        config_file = Path("config.json")
        if config_file.exists():
            try:
                with open(config_file) as f:
                    config_data = json.load(f)
                    self.credentials.update(config_data.get("credentials", {}))
            except Exception as e:
                logger.warning(f"Could not load config file: {e}")
    
    def get_authenticated_client(self):
        """Get an authenticated GitHub SDK client."""
        try:
            from github import Github
            
            # Get GitHub token
            token = (self.credentials.get("github_token") or 
                    self.credentials.get("github_access_token"))
            
            if not token:
                logger.warning("No GitHub token found. Some operations may be limited.")
                return Github()  # Unauthenticated client
            
            return Github(token)
            
        except ImportError:
            logger.error("GitHub SDK not installed. Install with: pip install PyGithub")
            return None
        except Exception as e:
            logger.error(f"Failed to create GitHub client: {e}")
            return None

auth_manager = AuthenticationManager()


async def handle_authentication(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle authentication tool call.
    
    This method authenticates the user by validating the headers passed to it.
    """
    try:
        # Validate required parameters
        if "headers" not in arguments:
            raise ValueError("Missing required parameter: headers")
        
        # Extract parameters
        headers = arguments.get("headers")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"authentication executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing authentication: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_mask_authentication(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle mask_authentication tool call.
    
    This method masks the authentication details in the headers for security purposes.
    """
    try:
        # Validate required parameters
        if "headers" not in arguments:
            raise ValueError("Missing required parameter: headers")
        
        # Extract parameters
        headers = arguments.get("headers")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"mask_authentication executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing mask_authentication: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_withRequester(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle withRequester tool call.
    
    This method associates a requester with the current authentication process.
    """
    try:
        # Validate required parameters
        if "requester" not in arguments:
            raise ValueError("Missing required parameter: requester")
        
        # Extract parameters
        requester = arguments.get("requester")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"withRequester executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing withRequester: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_close(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle close tool call.
    
    Closes the current Github session.
    """
    try:
        # Validate required parameters

        
        # Extract parameters

        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"close executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing close: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_dump(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle dump tool call.
    
    Dumps a Python object into a file using a specific protocol.
    """
    try:
        # Validate required parameters
        if "obj" not in arguments:
            raise ValueError("Missing required parameter: obj")
        if "file" not in arguments:
            raise ValueError("Missing required parameter: file")
        if "protocol" not in arguments:
            raise ValueError("Missing required parameter: protocol")
        
        # Extract parameters
        obj = arguments.get("obj")
        file = arguments.get("file")
        protocol = arguments.get("protocol")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"dump executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing dump: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_load(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle load tool call.
    
    Loads a Python object from a file.
    """
    try:
        # Validate required parameters
        if "f" not in arguments:
            raise ValueError("Missing required parameter: f")
        
        # Extract parameters
        f = arguments.get("f")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"load executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing load: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_render_markdown(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle render_markdown tool call.
    
    Renders a markdown text in a specific context.
    """
    try:
        # Validate required parameters
        if "text" not in arguments:
            raise ValueError("Missing required parameter: text")
        if "context" not in arguments:
            raise ValueError("Missing required parameter: context")
        
        # Extract parameters
        text = arguments.get("text")
        context = arguments.get("context")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"render_markdown executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing render_markdown: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_withLazy(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle withLazy tool call.
    
    Sets the lazy loading mode for the Github class.
    """
    try:
        # Validate required parameters
        if "lazy" not in arguments:
            raise ValueError("Missing required parameter: lazy")
        
        # Extract parameters
        lazy = arguments.get("lazy")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"withLazy executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing withLazy: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_close(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle close tool call.
    
    Closes the current GithubIntegration instance
    """
    try:
        # Validate required parameters

        
        # Extract parameters

        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"close executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing close: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_create_jwt(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle create_jwt tool call.
    
    Creates a JSON Web Token with a specified expiration time
    """
    try:
        # Validate required parameters
        if "expiration" not in arguments:
            raise ValueError("Missing required parameter: expiration")
        
        # Extract parameters
        expiration = arguments.get("expiration")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"create_jwt executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing create_jwt: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_get_access_token(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle get_access_token tool call.
    
    Gets an access token for a specific installation with specified permissions
    """
    try:
        # Validate required parameters
        if "installation_id" not in arguments:
            raise ValueError("Missing required parameter: installation_id")
        if "permissions" not in arguments:
            raise ValueError("Missing required parameter: permissions")
        
        # Extract parameters
        installation_id = arguments.get("installation_id")
        permissions = arguments.get("permissions")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"get_access_token executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing get_access_token: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_withLazy(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle withLazy tool call.
    
    Sets the lazy loading property of the GithubIntegration instance
    """
    try:
        # Validate required parameters
        if "lazy" not in arguments:
            raise ValueError("Missing required parameter: lazy")
        
        # Extract parameters
        lazy = arguments.get("lazy")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"withLazy executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing withLazy: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_get_backoff_time(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle get_backoff_time tool call.
    
    Calculates the time to wait before making the next request.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        
        # Extract parameters
        self = arguments.get("self")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"get_backoff_time executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing get_backoff_time: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_get_retry_after(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle get_retry_after tool call.
    
    Extracts the 'Retry-After' value from the response headers.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        if "response" not in arguments:
            raise ValueError("Missing required parameter: response")
        
        # Extract parameters
        self = arguments.get("self")
        response = arguments.get("response")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"get_retry_after executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing get_retry_after: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_increment(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle increment tool call.
    
    Increments the retry count and raises an error if the maximum retry limit is reached.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        if "method" not in arguments:
            raise ValueError("Missing required parameter: method")
        if "url" not in arguments:
            raise ValueError("Missing required parameter: url")
        if "response" not in arguments:
            raise ValueError("Missing required parameter: response")
        if "error" not in arguments:
            raise ValueError("Missing required parameter: error")
        if "_pool" not in arguments:
            raise ValueError("Missing required parameter: _pool")
        if "_stacktrace" not in arguments:
            raise ValueError("Missing required parameter: _stacktrace")
        
        # Extract parameters
        self = arguments.get("self")
        method = arguments.get("method")
        url = arguments.get("url")
        response = arguments.get("response")
        error = arguments.get("error")
        _pool = arguments.get("_pool")
        _stacktrace = arguments.get("_stacktrace")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"increment executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing increment: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_is_exhausted(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle is_exhausted tool call.
    
    Checks if the maximum retry limit has been reached.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        
        # Extract parameters
        self = arguments.get("self")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"is_exhausted executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing is_exhausted: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_is_retry(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle is_retry tool call.
    
    Determines if the request should be retried based on the HTTP method, status code, and 'Retry-After' header.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        if "method" not in arguments:
            raise ValueError("Missing required parameter: method")
        if "status_code" not in arguments:
            raise ValueError("Missing required parameter: status_code")
        if "has_retry_after" not in arguments:
            raise ValueError("Missing required parameter: has_retry_after")
        
        # Extract parameters
        self = arguments.get("self")
        method = arguments.get("method")
        status_code = arguments.get("status_code")
        has_retry_after = arguments.get("has_retry_after")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"is_retry executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing is_retry: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_new(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle new tool call.
    
    Creates a new instance of the GithubRetry class with the same settings.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        if "kw" not in arguments:
            raise ValueError("Missing required parameter: kw")
        
        # Extract parameters
        self = arguments.get("self")
        kw = arguments.get("kw")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"new executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing new: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_parse_retry_after(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle parse_retry_after tool call.
    
    Parses the 'Retry-After' header value into a number of seconds.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        if "retry_after" not in arguments:
            raise ValueError("Missing required parameter: retry_after")
        
        # Extract parameters
        self = arguments.get("self")
        retry_after = arguments.get("retry_after")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"parse_retry_after executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing parse_retry_after: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_sleep(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle sleep tool call.
    
    Pauses execution for a number of seconds based on the 'Retry-After' header value.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        if "response" not in arguments:
            raise ValueError("Missing required parameter: response")
        
        # Extract parameters
        self = arguments.get("self")
        response = arguments.get("response")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"sleep executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing sleep: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_sleep_for_retry(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle sleep_for_retry tool call.
    
    Pauses execution for a number of seconds based on the 'Retry-After' header value or the backoff time.
    """
    try:
        # Validate required parameters
        if "self" not in arguments:
            raise ValueError("Missing required parameter: self")
        if "response" not in arguments:
            raise ValueError("Missing required parameter: response")
        
        # Extract parameters
        self = arguments.get("self")
        response = arguments.get("response")
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {"status": "success", "message": f"sleep_for_retry executed successfully"}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing sleep_for_retry: {e}")
        return [types.TextContent(type="text", text=f"Error: {str(e)}")]

async def handle_Github_resource(resource_id: str) -> ReadResourceResult:
    """Handle Github resource read.
    
    A class representing the Github API.
    """
    try:
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # TODO: Implement actual resource reading
        content = f"Resource {resource_id} data for Github"
        
        return ReadResourceResult(
            contents=[TextContent(type="text", text=content)]
        )
        
    except Exception as e:
        logger.error(f"Error reading Github resource: {e}")
        raise Exception(f"Failed to read resource: {str(e)}")

async def handle_GithubIntegration_resource(resource_id: str) -> ReadResourceResult:
    """Handle GithubIntegration resource read.
    
    A class for integrating with Github
    """
    try:
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # TODO: Implement actual resource reading
        content = f"Resource {resource_id} data for GithubIntegration"
        
        return ReadResourceResult(
            contents=[TextContent(type="text", text=content)]
        )
        
    except Exception as e:
        logger.error(f"Error reading GithubIntegration resource: {e}")
        raise Exception(f"Failed to read resource: {str(e)}")

class GithubMCPServer:
    """MCP Server for github SDK."""
    
    def __init__(self):
        self.server = Server("github-mcp-server")
        self._setup_handlers()
    
    def _setup_handlers(self):
        """Setup MCP handlers."""
        
        @self.server.list_tools()
        async def list_tools() -> List[Tool]:
            """List available tools."""
            return [
                Tool(
                    name="authentication",
                    description="This method authenticates the user by validating the headers passed to it.",
                    inputSchema={'type': 'object', 'properties': {'headers': {'type': 'string', 'description': 'The headers containing the authentication information.'}}, 'required': ['headers']}
                ),
                Tool(
                    name="mask_authentication",
                    description="This method masks the authentication details in the headers for security purposes.",
                    inputSchema={'type': 'object', 'properties': {'headers': {'type': 'string', 'description': 'The headers containing the authentication information.'}}, 'required': ['headers']}
                ),
                Tool(
                    name="withRequester",
                    description="This method associates a requester with the current authentication process.",
                    inputSchema={'type': 'object', 'properties': {'requester': {'type': 'string', 'description': 'The identifier of the requester.'}}, 'required': ['requester']}
                ),
                Tool(
                    name="close",
                    description="Closes the current Github session.",
                    inputSchema={'type': 'object', 'properties': {}, 'required': []}
                ),
                Tool(
                    name="dump",
                    description="Dumps a Python object into a file using a specific protocol.",
                    inputSchema={'type': 'object', 'properties': {'obj': {'type': 'string', 'description': 'The Python object to be dumped.'}, 'file': {'type': 'string', 'description': 'The file where the object will be dumped.'}, 'protocol': {'type': 'integer', 'description': 'The protocol to be used for dumping the object.'}}, 'required': ['obj', 'file', 'protocol']}
                ),
                Tool(
                    name="load",
                    description="Loads a Python object from a file.",
                    inputSchema={'type': 'object', 'properties': {'f': {'type': 'string', 'description': 'The file from which the object will be loaded.'}}, 'required': ['f']}
                ),
                Tool(
                    name="render_markdown",
                    description="Renders a markdown text in a specific context.",
                    inputSchema={'type': 'object', 'properties': {'text': {'type': 'string', 'description': 'The markdown text to be rendered.'}, 'context': {'type': 'string', 'description': 'The context in which the markdown will be rendered.'}}, 'required': ['text', 'context']}
                ),
                Tool(
                    name="withLazy",
                    description="Sets the lazy loading mode for the Github class.",
                    inputSchema={'type': 'object', 'properties': {'lazy': {'type': 'boolean', 'description': 'The lazy loading mode to be set.'}}, 'required': ['lazy']}
                ),
                Tool(
                    name="close",
                    description="Closes the current GithubIntegration instance",
                    inputSchema={'type': 'object', 'properties': {}, 'required': []}
                ),
                Tool(
                    name="create_jwt",
                    description="Creates a JSON Web Token with a specified expiration time",
                    inputSchema={'type': 'object', 'properties': {'expiration': {'type': 'integer', 'description': 'The expiration time of the JWT in seconds'}}, 'required': ['expiration']}
                ),
                Tool(
                    name="get_access_token",
                    description="Gets an access token for a specific installation with specified permissions",
                    inputSchema={'type': 'object', 'properties': {'installation_id': {'type': 'integer', 'description': 'The ID of the installation'}, 'permissions': {'type': 'object', 'description': 'The permissions for the access token'}}, 'required': ['installation_id', 'permissions']}
                ),
                Tool(
                    name="withLazy",
                    description="Sets the lazy loading property of the GithubIntegration instance",
                    inputSchema={'type': 'object', 'properties': {'lazy': {'type': 'boolean', 'description': 'The lazy loading property value'}}, 'required': ['lazy']}
                ),
                Tool(
                    name="get_backoff_time",
                    description="Calculates the time to wait before making the next request.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}}, 'required': ['self']}
                ),
                Tool(
                    name="get_retry_after",
                    description="Extracts the 'Retry-After' value from the response headers.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}, 'response': {'type': 'string', 'description': 'Response object from the request'}}, 'required': ['self', 'response']}
                ),
                Tool(
                    name="increment",
                    description="Increments the retry count and raises an error if the maximum retry limit is reached.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}, 'method': {'type': 'string', 'description': 'HTTP method of the request'}, 'url': {'type': 'string', 'description': 'URL of the request'}, 'response': {'type': 'string', 'description': 'Response object from the request'}, 'error': {'type': 'string', 'description': 'Exception raised during the request'}, '_pool': {'type': 'string', 'description': 'Connection pool used for the request'}, '_stacktrace': {'type': 'string', 'description': 'Stack trace of the exception'}}, 'required': ['self', 'method', 'url', 'response', 'error', '_pool', '_stacktrace']}
                ),
                Tool(
                    name="is_exhausted",
                    description="Checks if the maximum retry limit has been reached.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}}, 'required': ['self']}
                ),
                Tool(
                    name="is_retry",
                    description="Determines if the request should be retried based on the HTTP method, status code, and 'Retry-After' header.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}, 'method': {'type': 'string', 'description': 'HTTP method of the request'}, 'status_code': {'type': 'string', 'description': 'HTTP status code of the response'}, 'has_retry_after': {'type': 'string', 'description': "Indicates if the 'Retry-After' header is present in the response"}}, 'required': ['self', 'method', 'status_code', 'has_retry_after']}
                ),
                Tool(
                    name="new",
                    description="Creates a new instance of the GithubRetry class with the same settings.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}, 'kw': {'type': 'string', 'description': 'Keyword arguments to pass to the GithubRetry constructor'}}, 'required': ['self', 'kw']}
                ),
                Tool(
                    name="parse_retry_after",
                    description="Parses the 'Retry-After' header value into a number of seconds.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}, 'retry_after': {'type': 'string', 'description': "'Retry-After' header value"}}, 'required': ['self', 'retry_after']}
                ),
                Tool(
                    name="sleep",
                    description="Pauses execution for a number of seconds based on the 'Retry-After' header value.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}, 'response': {'type': 'string', 'description': 'Response object from the request'}}, 'required': ['self', 'response']}
                ),
                Tool(
                    name="sleep_for_retry",
                    description="Pauses execution for a number of seconds based on the 'Retry-After' header value or the backoff time.",
                    inputSchema={'type': 'object', 'properties': {'self': {'type': 'string', 'description': 'Instance of the GithubRetry class'}, 'response': {'type': 'string', 'description': 'Response object from the request'}}, 'required': ['self', 'response']}
                )
            ]
        
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Dict[str, Any]) -> List[types.ContentBlock]:
            """Handle tool calls."""
            tool_handlers = {
                "authentication": handle_authentication,
                "mask_authentication": handle_mask_authentication,
                "withRequester": handle_withRequester,
                "close": handle_close,
                "dump": handle_dump,
                "load": handle_load,
                "render_markdown": handle_render_markdown,
                "withLazy": handle_withLazy,
                "close": handle_close,
                "create_jwt": handle_create_jwt,
                "get_access_token": handle_get_access_token,
                "withLazy": handle_withLazy,
                "get_backoff_time": handle_get_backoff_time,
                "get_retry_after": handle_get_retry_after,
                "increment": handle_increment,
                "is_exhausted": handle_is_exhausted,
                "is_retry": handle_is_retry,
                "new": handle_new,
                "parse_retry_after": handle_parse_retry_after,
                "sleep": handle_sleep,
                "sleep_for_retry": handle_sleep_for_retry,
            }
            
            if name not in tool_handlers:
                raise ValueError(f"Unknown tool: {name}")
            
            return await tool_handlers[name](arguments)
        
        @self.server.list_resources()
        async def list_resources() -> List[Resource]:
            """List available resources."""
            return [
                Resource(
                    uri="Github://",
                    name="Github",
                    description="A class representing the Github API.",
                    mimeType="application/json"
                ),
                Resource(
                    uri="GithubIntegration://",
                    name="GithubIntegration",
                    description="A class for integrating with Github",
                    mimeType="application/json"
                )
            ]
        
        @self.server.read_resource()
        async def read_resource(uri: str) -> ReadResourceResult:
            """Read a resource."""
            # Parse URI to determine resource type and ID
            if "://" in uri:
                scheme, path = uri.split("://", 1)
                resource_id = path
            else:
                scheme = "default"
                resource_id = uri
            
            resource_handlers = {
                "Github": handle_Github_resource,
                "GithubIntegration": handle_GithubIntegration_resource,
            }
            
            if scheme not in resource_handlers:
                raise ValueError(f"Unknown resource scheme: {scheme}")
            
            return await resource_handlers[scheme](resource_id)
    
    async def run(self):
        """Run the MCP server."""
        async with stdio_server() as (read_stream, write_stream):
            await self.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="github-mcp-server",
                    server_version="1.0.0",
                    capabilities=self.server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities=None
                    )
                )
            )

async def main():
    """Main entry point."""
    server = GithubMCPServer()
    await server.run()

if __name__ == "__main__":
    asyncio.run(main())
