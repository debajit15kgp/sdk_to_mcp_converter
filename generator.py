"""
MCP Server Code Generator - Generates MCP server code from SDK analysis.
"""

import json
from typing import Dict, List, Any, Optional
from pathlib import Path


class MCPGenerator:
    """
    Generates MCP server code based on SDK analysis.
    
    This class creates:
    - MCP server implementation
    - Tool definitions
    - Resource definitions
    - Authentication handling
    - Error handling
    - Tests
    """
    
    def __init__(self):
        self.template_dir = Path(__file__).parent / "templates"
    
    def generate_mcp_server(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any], config: Any) -> Dict[str, str]:
        """
        Generate complete MCP server code.
        
        Args:
            sdk_info: SDK structure information from introspector
            analyzed_methods: LLM-analyzed method information
            config: Conversion configuration
            
        Returns:
            Dictionary mapping filenames to file contents
        """
        files = {}
        
        # Generate main MCP server
        files["mcp_server.py"] = self._generate_main_server(sdk_info, analyzed_methods, config)
        
        # Generate requirements.txt
        files["requirements.txt"] = self._generate_requirements(sdk_info, config)
        
        # Generate README.md
        files["README.md"] = self._generate_readme(sdk_info, analyzed_methods, config)
        
        # Generate configuration file
        files["config.json"] = self._generate_config(sdk_info, analyzed_methods, config)
        
        # Generate example usage
        files["example_usage.py"] = self._generate_example_usage(sdk_info, analyzed_methods, config)
        
        return files
    
    def _generate_main_server(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any], config: Any) -> str:
        """Generate the main MCP server implementation."""
        
        tools = analyzed_methods.get("tools", [])
        resources = analyzed_methods.get("resources", [])
        
        # Generate imports
        imports = self._generate_imports(sdk_info, config)
        
        # Generate authentication setup
        auth_setup = self._generate_auth_setup(config)
        
        # Generate tool handlers
        tool_handlers = self._generate_tool_handlers(tools, sdk_info)
        
        # Generate resource handlers
        resource_handlers = self._generate_resource_handlers(resources, sdk_info)
        
        # Generate main server class
        server_class = self._generate_server_class(tools, resources, config)
        
        # Generate main function
        main_function = self._generate_main_function(config)
        
        return f'''"""
MCP Server for {config.sdk_name} SDK

Auto-generated by SDK-to-MCP converter.
"""

{imports}

{auth_setup}

{tool_handlers}

{resource_handlers}

{server_class}

{main_function}
'''
    
    def _generate_imports(self, sdk_info: Dict[str, Any], config: Any) -> str:
        """Generate import statements."""
        module_name = config.sdk_module
        
        return f'''import asyncio
import json
import logging
import os
import sys
from typing import Any, Dict, List, Optional, Union
from pathlib import Path

# MCP imports
from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.server.lowlevel.server import NotificationOptions
from mcp.server.stdio import stdio_server
from mcp.types import (
    Resource, Tool, TextContent, ImageContent, EmbeddedResource,
    CallToolRequest, CallToolResult, ListResourcesRequest, ListResourcesResult,
    ReadResourceRequest, ReadResourceResult, GetPromptRequest, GetPromptResult,
    Prompt, PromptMessage, PromptArgument
)
from mcp import types

# SDK imports
import {module_name}

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
'''
    
    def _generate_auth_setup(self, config: Any) -> str:
        """Generate authentication setup code."""
        if config.sdk_name.lower() == "azure":
            return self._generate_azure_auth_setup(config)
        elif config.sdk_name.lower() == "kubernetes":
            return self._generate_kubernetes_auth_setup(config)
        elif config.sdk_name.lower() == "github":
            return self._generate_github_auth_setup(config)
        else:
            return self._generate_generic_auth_setup(config)
    
    def _generate_azure_auth_setup(self, config: Any) -> str:
        """Generate Azure-specific authentication setup."""
        return f'''class AuthenticationManager:
    """Manages authentication for the Azure SDK."""
    
    def __init__(self):
        self.credentials = {{}}
        self.subscription_id = None
        self._load_credentials()
    
    def _load_credentials(self):
        """Load Azure credentials from environment variables or config file."""
        # Load Azure-specific environment variables
        azure_vars = [
            "AZURE_CLIENT_ID", "AZURE_CLIENT_SECRET", "AZURE_TENANT_ID",
            "AZURE_SUBSCRIPTION_ID", "AZURE_RESOURCE_GROUP"
        ]
        
        for var in azure_vars:
            value = os.getenv(var)
            if value:
                self.credentials[var.lower()] = value
        
        # Set subscription ID for Azure clients
        self.subscription_id = os.getenv("AZURE_SUBSCRIPTION_ID")
        
        # Load from config file if it exists
        config_file = Path("config.json")
        if config_file.exists():
            try:
                with open(config_file) as f:
                    config_data = json.load(f)
                    self.credentials.update(config_data.get("credentials", {{}}))
                    self.subscription_id = config_data.get("subscription_id", self.subscription_id)
            except Exception as e:
                logger.warning(f"Could not load config file: {{e}}")
    
    def get_authenticated_client(self):
        """Get an authenticated Azure SDK client."""
        try:
            from azure.identity import DefaultAzureCredential, ClientSecretCredential
            from azure.mgmt.resource import ResourceManagementClient
            
            # Try different authentication methods
            if all(k in self.credentials for k in ["azure_client_id", "azure_client_secret", "azure_tenant_id"]):
                # Use service principal authentication
                credential = ClientSecretCredential(
                    tenant_id=self.credentials["azure_tenant_id"],
                    client_id=self.credentials["azure_client_id"],
                    client_secret=self.credentials["azure_client_secret"]
                )
            else:
                # Use default credential (managed identity, Azure CLI, etc.)
                credential = DefaultAzureCredential()
            
            # Create Resource Management client
            client = ResourceManagementClient(credential, self.subscription_id)
            return client
            
        except ImportError:
            logger.error("Azure SDK not installed. Install with: pip install azure-identity azure-mgmt-resource")
            return None
        except Exception as e:
            logger.error(f"Failed to create Azure client: {{e}}")
            return None

auth_manager = AuthenticationManager()
'''
    
    def _generate_kubernetes_auth_setup(self, config: Any) -> str:
        """Generate Kubernetes-specific authentication setup."""
        return f'''class AuthenticationManager:
    """Manages authentication for the Kubernetes SDK."""
    
    def __init__(self):
        self.credentials = {{}}
        self._load_credentials()
    
    def _load_credentials(self):
        """Load Kubernetes credentials from environment variables or config file."""
        # Load Kubernetes-specific environment variables
        k8s_vars = ["KUBECONFIG", "KUBERNETES_SERVICE_HOST"]
        
        for var in k8s_vars:
            value = os.getenv(var)
            if value:
                self.credentials[var.lower()] = value
        
        # Load from config file if it exists
        config_file = Path("config.json")
        if config_file.exists():
            try:
                with open(config_file) as f:
                    config_data = json.load(f)
                    self.credentials.update(config_data.get("credentials", {{}}))
            except Exception as e:
                logger.warning(f"Could not load config file: {{e}}")
    
    def get_authenticated_client(self):
        """Get an authenticated Kubernetes SDK client."""
        try:
            from kubernetes import client, config
            
            # Try to load kubeconfig
            try:
                config.load_kube_config()
                logger.info("Loaded kubeconfig from default location")
            except:
                # Try in-cluster config
                try:
                    config.load_incluster_config()
                    logger.info("Loaded in-cluster config")
                except:
                    logger.warning("Could not load Kubernetes config")
            
            # Create API clients
            api_client = client.ApiClient()
            return api_client
            
        except ImportError:
            logger.error("Kubernetes SDK not installed. Install with: pip install kubernetes")
            return None
        except Exception as e:
            logger.error(f"Failed to create Kubernetes client: {{e}}")
            return None

auth_manager = AuthenticationManager()
'''
    
    def _generate_github_auth_setup(self, config: Any) -> str:
        """Generate GitHub-specific authentication setup."""
        return f'''class AuthenticationManager:
    """Manages authentication for the GitHub SDK."""
    
    def __init__(self):
        self.credentials = {{}}
        self._load_credentials()
    
    def _load_credentials(self):
        """Load GitHub credentials from environment variables or config file."""
        # Load GitHub-specific environment variables
        github_vars = ["GITHUB_TOKEN", "GITHUB_ACCESS_TOKEN"]
        
        for var in github_vars:
            value = os.getenv(var)
            if value:
                self.credentials[var.lower()] = value
        
        # Load from config file if it exists
        config_file = Path("config.json")
        if config_file.exists():
            try:
                with open(config_file) as f:
                    config_data = json.load(f)
                    self.credentials.update(config_data.get("credentials", {{}}))
            except Exception as e:
                logger.warning(f"Could not load config file: {{e}}")
    
    def get_authenticated_client(self):
        """Get an authenticated GitHub SDK client."""
        try:
            from github import Github
            
            # Get GitHub token
            token = (self.credentials.get("github_token") or 
                    self.credentials.get("github_access_token"))
            
            if not token:
                logger.warning("No GitHub token found. Some operations may be limited.")
                return Github()  # Unauthenticated client
            
            return Github(token)
            
        except ImportError:
            logger.error("GitHub SDK not installed. Install with: pip install PyGithub")
            return None
        except Exception as e:
            logger.error(f"Failed to create GitHub client: {{e}}")
            return None

auth_manager = AuthenticationManager()
'''
    
    def _generate_generic_auth_setup(self, config: Any) -> str:
        """Generate generic authentication setup."""
        return f'''class AuthenticationManager:
    """Manages authentication for the {config.sdk_name} SDK."""
    
    def __init__(self):
        self.credentials = {{}}
        self._load_credentials()
    
    def _load_credentials(self):
        """Load credentials from environment variables or config file."""
        # Load from environment variables
        env_vars = {self._get_env_vars_for_sdk(config.sdk_name)}
        for var in env_vars:
            value = os.getenv(var)
            if value:
                self.credentials[var.lower()] = value
        
        # Load from config file if it exists
        config_file = Path("config.json")
        if config_file.exists():
            try:
                with open(config_file) as f:
                    config_data = json.load(f)
                    self.credentials.update(config_data.get("credentials", {{}}))
            except Exception as e:
                logger.warning(f"Could not load config file: {{e}}")
    
    def get_authenticated_client(self):
        """Get an authenticated SDK client."""
        # This will be customized based on the specific SDK
        return self._create_client()
    
    def _create_client(self):
        """Create and configure the SDK client."""
        # Placeholder - will be customized per SDK
        return None

auth_manager = AuthenticationManager()
'''
    
    def _get_env_vars_for_sdk(self, sdk_name: str) -> List[str]:
        """Get common environment variable names for different SDKs."""
        env_mapping = {
            "github": ["GITHUB_TOKEN", "GITHUB_ACCESS_TOKEN"],
            "kubernetes": ["KUBECONFIG", "KUBERNETES_SERVICE_HOST"],
            "azure": ["AZURE_CLIENT_ID", "AZURE_CLIENT_SECRET", "AZURE_TENANT_ID", "AZURE_SUBSCRIPTION_ID", "AZURE_RESOURCE_GROUP"],
            "aws": ["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY", "AWS_REGION"]
        }
        return env_mapping.get(sdk_name.lower(), [f"{sdk_name.upper()}_TOKEN", f"{sdk_name.upper()}_API_KEY"])
    
    def _generate_tool_handlers(self, tools: List[Dict[str, Any]], sdk_info: Dict[str, Any]) -> str:
        """Generate tool handler functions."""
        if not tools:
            return "# No tools generated"
        
        handlers = []
        for tool in tools:
            handler = self._generate_single_tool_handler(tool, sdk_info)
            handlers.append(handler)
        
        return "\n\n".join(handlers)
    
    def _generate_single_tool_handler(self, tool: Dict[str, Any], sdk_info: Dict[str, Any]) -> str:
        """Generate handler for a single tool."""
        tool_name = tool.get("name", "unknown_tool")
        description = tool.get("description", "No description available")
        parameters = tool.get("parameters", [])
        
        # Generate parameter validation
        param_validation = []
        param_extraction = []
        
        for param in parameters:
            param_name = param.get("name", "unknown")
            param_type = param.get("type", "str")
            required = param.get("required", True)
            
            if required:
                param_validation.append(f'        if "{param_name}" not in arguments:')
                param_validation.append(f'            raise ValueError("Missing required parameter: {param_name}")')
            
            param_extraction.append(f'        {param_name} = arguments.get("{param_name}")')
        
        param_validation_code = "\n".join(param_validation)
        param_extraction_code = "\n".join(param_extraction)
        
        return f'''async def handle_{tool_name}(arguments: Dict[str, Any]) -> List[types.ContentBlock]:
    """Handle {tool_name} tool call.
    
    {description}
    """
    try:
        # Validate required parameters
{param_validation_code}
        
        # Extract parameters
{param_extraction_code}
        
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # Execute the SDK method
        # TODO: Implement actual SDK method call
        result = {{"status": "success", "message": f"{tool_name} executed successfully"}}
        
        return [types.TextContent(type="text", text=json.dumps(result, indent=2))]
        
    except Exception as e:
        logger.error(f"Error executing {tool_name}: {{e}}")
        return [types.TextContent(type="text", text=f"Error: {{str(e)}}")]'''
    
    def _generate_resource_handlers(self, resources: List[Dict[str, Any]], sdk_info: Dict[str, Any]) -> str:
        """Generate resource handler functions."""
        if not resources:
            return "# No resources generated"
        
        handlers = []
        for resource in resources:
            handler = self._generate_single_resource_handler(resource, sdk_info)
            handlers.append(handler)
        
        return "\n\n".join(handlers)
    
    def _sanitize_name_for_function(self, name: str) -> str:
        """Sanitize a name for use in Python function names."""
        # Replace spaces and special characters with underscores
        import re
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        # Remove multiple consecutive underscores
        sanitized = re.sub(r'_+', '_', sanitized)
        # Remove leading/trailing underscores
        sanitized = sanitized.strip('_')
        # Ensure it starts with a letter or underscore
        if sanitized and not sanitized[0].isalpha() and sanitized[0] != '_':
            sanitized = '_' + sanitized
        return sanitized or 'unknown_resource'
    
    def _generate_single_resource_handler(self, resource: Dict[str, Any], sdk_info: Dict[str, Any]) -> str:
        """Generate handler for a single resource."""
        resource_name = resource.get("name", "unknown_resource")
        sanitized_name = self._sanitize_name_for_function(resource_name)
        description = resource.get("description", "No description available")
        methods = resource.get("methods", [])
        
        return f'''async def handle_{sanitized_name}_resource(resource_id: str) -> ReadResourceResult:
    """Handle {resource_name} resource read.
    
    {description}
    """
    try:
        # Get authenticated client
        client = auth_manager.get_authenticated_client()
        
        # TODO: Implement actual resource reading
        content = f"Resource {{resource_id}} data for {resource_name}"
        
        return ReadResourceResult(
            contents=[TextContent(type="text", text=content)]
        )
        
    except Exception as e:
        logger.error(f"Error reading {resource_name} resource: {{e}}")
        raise Exception(f"Failed to read resource: {{str(e)}}")'''
    
    def _generate_server_class(self, tools: List[Dict[str, Any]], resources: List[Dict[str, Any]], config: Any) -> str:
        """Generate the main MCP server class."""
        
        # Generate tool definitions
        tool_definitions = []
        for tool in tools:
            tool_def = self._generate_tool_definition(tool)
            tool_definitions.append(tool_def)
        
        # Generate resource definitions
        resource_definitions = []
        for resource in resources:
            resource_def = self._generate_resource_definition(resource)
            resource_definitions.append(resource_def)
        
        return f'''class {config.sdk_name.title()}MCPServer:
    """MCP Server for {config.sdk_name} SDK."""
    
    def __init__(self):
        self.server = Server("{config.sdk_name.lower()}-mcp-server")
        self._setup_handlers()
    
    def _setup_handlers(self):
        """Setup MCP handlers."""
        
        @self.server.list_tools()
        async def list_tools() -> List[Tool]:
            """List available tools."""
            return [
{self._indent_tool_definitions(tool_definitions)}
            ]
        
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Dict[str, Any]) -> List[types.ContentBlock]:
            """Handle tool calls."""
            tool_handlers = {{
{self._indent_tool_handlers(tools)}
            }}
            
            if name not in tool_handlers:
                raise ValueError(f"Unknown tool: {{name}}")
            
            return await tool_handlers[name](arguments)
        
        @self.server.list_resources()
        async def list_resources() -> List[Resource]:
            """List available resources."""
            return [
{self._indent_resource_definitions(resource_definitions)}
            ]
        
        @self.server.read_resource()
        async def read_resource(uri: str) -> ReadResourceResult:
            """Read a resource."""
            # Parse URI to determine resource type and ID
            if "://" in uri:
                scheme, path = uri.split("://", 1)
                resource_id = path
            else:
                scheme = "default"
                resource_id = uri
            
            resource_handlers = {{
{self._indent_resource_handlers(resources)}
            }}
            
            if scheme not in resource_handlers:
                raise ValueError(f"Unknown resource scheme: {{scheme}}")
            
            return await resource_handlers[scheme](resource_id)
    
    async def run(self):
        """Run the MCP server."""
        async with stdio_server() as (read_stream, write_stream):
            await self.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="{config.sdk_name.lower()}-mcp-server",
                    server_version="1.0.0",
                    capabilities=self.server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities=None
                    )
                )
            )'''
    
    def _generate_tool_definition(self, tool: Dict[str, Any]) -> str:
        """Generate tool definition."""
        tool_name = tool.get("name", "unknown_tool")
        description = tool.get("description", "No description")
        parameters = tool.get("parameters", [])
        
        # Generate input schema
        properties = {}
        required = []
        
        for param in parameters:
            param_name = param.get("name", "unknown")
            param_type = param.get("type", "string")
            required_flag = param.get("required", True)
            
            properties[param_name] = {
                "type": self._map_python_type_to_json(param_type),
                "description": param.get("description", f"Parameter {param_name}")
            }
            
            if required_flag:
                required.append(param_name)
        
        input_schema = {
            "type": "object",
            "properties": properties,
            "required": required
        }
        
        return f'''                Tool(
                    name="{tool_name}",
                    description="{description}",
                    inputSchema={input_schema}
                )'''
    
    def _generate_resource_definition(self, resource: Dict[str, Any]) -> str:
        """Generate resource definition."""
        resource_name = resource.get("name", "unknown_resource")
        description = resource.get("description", "No description")
        
        return f'''                Resource(
                    uri="kubernetes://resource/{resource_name}",
                    name="{resource_name}",
                    description="{description}",
                    mimeType="application/json"
                )'''
    
    def _indent_tool_definitions(self, tool_definitions: List[str]) -> str:
        """Indent tool definitions for proper formatting."""
        return ",\n".join(tool_definitions)
    
    def _indent_tool_handlers(self, tools: List[Dict[str, Any]]) -> str:
        """Generate tool handler mapping."""
        handlers = []
        for tool in tools:
            tool_name = tool.get("name", "unknown_tool")
            handlers.append(f'                "{tool_name}": handle_{tool_name},')
        return "\n".join(handlers)
    
    def _indent_resource_definitions(self, resource_definitions: List[str]) -> str:
        """Indent resource definitions for proper formatting."""
        return ",\n".join(resource_definitions)
    
    def _indent_resource_handlers(self, resources: List[Dict[str, Any]]) -> str:
        """Generate resource handler mapping."""
        handlers = []
        for resource in resources:
            resource_name = resource.get("name", "unknown_resource")
            sanitized_name = self._sanitize_name_for_function(resource_name)
            handlers.append(f'                "{resource_name}": handle_{sanitized_name}_resource,')
        return "\n".join(handlers)
    
    def _map_python_type_to_json(self, python_type: str) -> str:
        """Map Python type hints to JSON schema types."""
        type_mapping = {
            "str": "string",
            "int": "integer",
            "float": "number",
            "bool": "boolean",
            "list": "array",
            "dict": "object",
            "None": "null"
        }
        return type_mapping.get(python_type.lower(), "string")
    
    def _generate_main_function(self, config: Any) -> str:
        """Generate the main function."""
        return f'''async def main():
    """Main entry point."""
    server = {config.sdk_name.title()}MCPServer()
    await server.run()

if __name__ == "__main__":
    asyncio.run(main())'''
    
    def _generate_requirements(self, sdk_info: Dict[str, Any], config: Any) -> str:
        """Generate requirements.txt file."""
        requirements = [
            "mcp>=1.0.0",
            config.sdk_module,
            "openai>=1.0.0",
            "asyncio",
            "typing-extensions"
        ]
        
        return "\n".join(requirements)
    
    def _generate_readme(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any], config: Any) -> str:
        """Generate README.md file."""
        tools = analyzed_methods.get("tools", [])
        resources = analyzed_methods.get("resources", [])
        
        return f'''# {config.sdk_name.title()} MCP Server

Auto-generated MCP server for the {config.sdk_name} SDK.

## Overview

This MCP server provides AI assistants with access to {config.sdk_name} functionality through the Model Context Protocol.

## Features

- **{len(tools)} Tools**: Execute {config.sdk_name} operations
- **{len(resources)} Resources**: Access {config.sdk_name} data
- **Authentication**: Secure credential management
- **Error Handling**: Robust error reporting

## Installation

1. Install dependencies:
```bash
pip install -r requirements.txt
```

2. Configure authentication (see Configuration section)

3. Run the server:
```bash
python mcp_server.py
```

## Configuration

Set the following environment variables:

{self._generate_env_vars_docs(config.sdk_name)}

Or create a `config.json` file:
```json
{{
    "credentials": {{
        "api_key": "your_api_key_here"
    }}
}}
```

## Available Tools

{self._generate_tools_docs(tools)}

## Available Resources

{self._generate_resources_docs(resources)}

## Usage Example

See `example_usage.py` for detailed usage examples.

## Generated by SDK-to-MCP Converter

This server was automatically generated from the {config.sdk_name} SDK.
'''
    
    def _generate_env_vars_docs(self, sdk_name: str) -> str:
        """Generate environment variables documentation."""
        env_vars = self._get_env_vars_for_sdk(sdk_name)
        return "\n".join([f"- `{var}`: {var.replace('_', ' ').lower()}" for var in env_vars])
    
    def _generate_tools_docs(self, tools: List[Dict[str, Any]]) -> str:
        """Generate tools documentation."""
        if not tools:
            return "No tools available."
        
        docs = []
        for tool in tools:
            name = tool.get("name", "unknown")
            description = tool.get("description", "No description")
            docs.append(f"- **{name}**: {description}")
        
        return "\n".join(docs)
    
    def _generate_resources_docs(self, resources: List[Dict[str, Any]]) -> str:
        """Generate resources documentation."""
        if not resources:
            return "No resources available."
        
        docs = []
        for resource in resources:
            name = resource.get("name", "unknown")
            description = resource.get("description", "No description")
            docs.append(f"- **{name}**: {description}")
        
        return "\n".join(docs)
    
    def _generate_config(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any], config: Any) -> str:
        """Generate configuration file."""
        config_data = {
            "sdk_name": config.sdk_name,
            "sdk_module": config.sdk_module,
            "generated_at": "2024-01-01T00:00:00Z",
            "tools_count": len(analyzed_methods.get("tools", [])),
            "resources_count": len(analyzed_methods.get("resources", [])),
            "credentials": {},
            "settings": {
                "max_retries": 3,
                "timeout": 30,
                "log_level": "INFO"
            }
        }
        
        return json.dumps(config_data, indent=2)
    
    def _generate_example_usage(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any], config: Any) -> str:
        """Generate example usage file."""
        tools = analyzed_methods.get("tools", [])
        
        example_tools = tools[:3]  # Show first 3 tools as examples
        
        examples = []
        for tool in example_tools:
            tool_name = tool.get("name", "unknown_tool")
            parameters = tool.get("parameters", [])
            
            example_params = {}
            for param in parameters[:2]:  # Show first 2 parameters
                param_name = param.get("name", "param")
                example_params[param_name] = f"example_{param_name}_value"
            
            examples.append(f'''
# Example: {tool_name}
{{
    "tool": "{tool_name}",
    "arguments": {json.dumps(example_params, indent=4)}
}}''')
        
        return f'''"""
Example usage of the {config.sdk_name.title()} MCP Server

This file demonstrates how to interact with the generated MCP server.
"""

import json
import asyncio
from mcp.client import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

async def main():
    """Example usage of the MCP server."""
    
    # Connect to the MCP server
    server_params = StdioServerParameters(
        command="python",
        args=["mcp_server.py"]
    )
    
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            # Initialize the session
            await session.initialize()
            
            # List available tools
            tools = await session.list_tools()
            print("Available tools:")
            for tool in tools.tools:
                print(f"- {{tool.name}}: {{tool.description}}")
            
            # Example tool calls
            examples = [
{self._indent_examples(examples)}
            ]
            
            for example in examples:
                print(f"\\nExecuting: {{example['tool']}}")
                try:
                    result = await session.call_tool(example["tool"], example["arguments"])
                    print(f"Result: {{result.content[0].text}}")
                except Exception as e:
                    print(f"Error: {{e}}")
            
            # List available resources
            resources = await session.list_resources()
            print("\\nAvailable resources:")
            for resource in resources.resources:
                print(f"- {{resource.name}}: {{resource.description}}")

if __name__ == "__main__":
    asyncio.run(main())
'''
    
    def _indent_examples(self, examples: List[str]) -> str:
        """Indent examples for proper formatting."""
        return ",\n".join(examples)
    
    def generate_tests(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any]) -> Dict[str, str]:
        """Generate test files."""
        files = {}
        
        # Generate main test file
        files["test_mcp_server.py"] = self._generate_main_tests(sdk_info, analyzed_methods)
        
        # Generate integration tests
        files["test_integration.py"] = self._generate_integration_tests(sdk_info, analyzed_methods)
        
        return files
    
    def _generate_main_tests(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any]) -> str:
        """Generate main test file."""
        return '''"""
Tests for the MCP server.
"""

import pytest
import asyncio
from unittest.mock import Mock, patch
from mcp_server import MCPServer

class TestMCPServer:
    """Test cases for the MCP server."""
    
    def setup_method(self):
        """Setup test fixtures."""
        self.server = MCPServer()
    
    @pytest.mark.asyncio
    async def test_server_initialization(self):
        """Test server initialization."""
        assert self.server is not None
        assert self.server.server is not None
    
    @pytest.mark.asyncio
    async def test_list_tools(self):
        """Test listing available tools."""
        tools = await self.server.server.list_tools()
        assert tools is not None
        assert isinstance(tools, list)
    
    @pytest.mark.asyncio
    async def test_list_resources(self):
        """Test listing available resources."""
        resources = await self.server.server.list_resources()
        assert resources is not None
        assert isinstance(resources, list)

if __name__ == "__main__":
    pytest.main([__file__])
'''
    
    def _generate_integration_tests(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any]) -> str:
        """Generate integration test file."""
        return '''"""
Integration tests for the MCP server.
"""

import pytest
import asyncio
from mcp.client import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

class TestIntegration:
    """Integration tests for the MCP server."""
    
    @pytest.mark.asyncio
    async def test_server_connection(self):
        """Test connecting to the MCP server."""
        server_params = StdioServerParameters(
            command="python",
            args=["mcp_server.py"]
        )
        
        async with stdio_client(server_params) as (read, write):
            async with ClientSession(read, write) as session:
                await session.initialize()
                
                # Test basic functionality
                tools = await session.list_tools()
                assert tools is not None
                
                resources = await session.list_resources()
                assert resources is not None

if __name__ == "__main__":
    pytest.main([__file__])
'''
    
    def _generate_example_usage(self, sdk_info: Dict[str, Any], analyzed_methods: Dict[str, Any], config: Any) -> str:
        """Generate example usage file."""
        tools = analyzed_methods.get("tools", [])
        tool_names = [tool.get("name", "unknown_tool") for tool in tools[:3]]  # Show first 3 tools
        
        return f'''#!/usr/bin/env python3
"""
Example usage of the {config.sdk_name} MCP server.
"""

import asyncio
from mcp.client.session import ClientSession
from mcp.client.stdio import stdio_client, StdioServerParameters

async def main():
    """Example client usage."""
    print("üöÄ Connecting to {config.sdk_name} MCP server...")
    
    # Connect to the MCP server
    server_params = StdioServerParameters(
        command="python",
        args=["mcp_server.py"]
    )
    
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            # Initialize the session
            await session.initialize()
            
            # List available tools
            tools = await session.list_tools()
            print(f"Available tools: {{len(tools.tools)}}")
            for tool in tools.tools:
                print(f"- {{tool.name}}: {{tool.description}}")
            
            # Example tool calls
            {self._generate_example_tool_calls(tool_names)}
            
            # List resources
            resources = await session.list_resources()
            print(f"\\nAvailable resources: {{len(resources.resources)}}")

{self._generate_example_tool_call_functions(tool_names)}

if __name__ == "__main__":
    asyncio.run(main())
'''
    
    def _generate_example_tool_calls(self, tool_names: List[str]) -> str:
        """Generate example tool call code."""
        calls = []
        for tool_name in tool_names:
            calls.append(f'            print(f"\\nExecuting: {tool_name}")\n            result = await session.call_tool("{tool_name}", {{}})\n            print(f"Result: {{result.content[0].text if result.content else \'No content\'}}")\n')
        return "".join(calls)
    
    def _generate_example_tool_call_functions(self, tool_names: List[str]) -> str:
        """Generate helper functions for tool calls."""
        functions = []
        for tool_name in tool_names:
            functions.append(f'''
async def call_{tool_name}(session):
    """Call {tool_name} tool."""
    try:
        result = await session.call_tool("{tool_name}", {{}})
        print(f"‚úÖ {tool_name}: {{result.content[0].text if result.content else \'Success\'}}")
        return result
    except Exception as e:
        print(f"‚ùå {tool_name} failed: {{e}}")
        return None
''')
        return "".join(functions)
